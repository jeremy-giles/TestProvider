// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'time_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$CleaningTimeStateTearOff {
  const _$CleaningTimeStateTearOff();

  CleaningTimeStateAny any() {
    return const CleaningTimeStateAny();
  }

  CleaningTimeStateInProgress inProgress({required CleaningTime cleaningTime}) {
    return CleaningTimeStateInProgress(
      cleaningTime: cleaningTime,
    );
  }

  CleaningTimeStateStopped stopped({required CleaningTime cleaningTime}) {
    return CleaningTimeStateStopped(
      cleaningTime: cleaningTime,
    );
  }
}

/// @nodoc
const $CleaningTimeState = _$CleaningTimeStateTearOff();

/// @nodoc
mixin _$CleaningTimeState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() any,
    required TResult Function(CleaningTime cleaningTime) inProgress,
    required TResult Function(CleaningTime cleaningTime) stopped,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? any,
    TResult Function(CleaningTime cleaningTime)? inProgress,
    TResult Function(CleaningTime cleaningTime)? stopped,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? any,
    TResult Function(CleaningTime cleaningTime)? inProgress,
    TResult Function(CleaningTime cleaningTime)? stopped,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CleaningTimeStateAny value) any,
    required TResult Function(CleaningTimeStateInProgress value) inProgress,
    required TResult Function(CleaningTimeStateStopped value) stopped,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(CleaningTimeStateAny value)? any,
    TResult Function(CleaningTimeStateInProgress value)? inProgress,
    TResult Function(CleaningTimeStateStopped value)? stopped,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CleaningTimeStateAny value)? any,
    TResult Function(CleaningTimeStateInProgress value)? inProgress,
    TResult Function(CleaningTimeStateStopped value)? stopped,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CleaningTimeStateCopyWith<$Res> {
  factory $CleaningTimeStateCopyWith(
          CleaningTimeState value, $Res Function(CleaningTimeState) then) =
      _$CleaningTimeStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$CleaningTimeStateCopyWithImpl<$Res>
    implements $CleaningTimeStateCopyWith<$Res> {
  _$CleaningTimeStateCopyWithImpl(this._value, this._then);

  final CleaningTimeState _value;
  // ignore: unused_field
  final $Res Function(CleaningTimeState) _then;
}

/// @nodoc
abstract class $CleaningTimeStateAnyCopyWith<$Res> {
  factory $CleaningTimeStateAnyCopyWith(CleaningTimeStateAny value,
          $Res Function(CleaningTimeStateAny) then) =
      _$CleaningTimeStateAnyCopyWithImpl<$Res>;
}

/// @nodoc
class _$CleaningTimeStateAnyCopyWithImpl<$Res>
    extends _$CleaningTimeStateCopyWithImpl<$Res>
    implements $CleaningTimeStateAnyCopyWith<$Res> {
  _$CleaningTimeStateAnyCopyWithImpl(
      CleaningTimeStateAny _value, $Res Function(CleaningTimeStateAny) _then)
      : super(_value, (v) => _then(v as CleaningTimeStateAny));

  @override
  CleaningTimeStateAny get _value => super._value as CleaningTimeStateAny;
}

/// @nodoc

class _$CleaningTimeStateAny implements CleaningTimeStateAny {
  const _$CleaningTimeStateAny();

  @override
  String toString() {
    return 'CleaningTimeState.any()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is CleaningTimeStateAny);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() any,
    required TResult Function(CleaningTime cleaningTime) inProgress,
    required TResult Function(CleaningTime cleaningTime) stopped,
  }) {
    return any();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? any,
    TResult Function(CleaningTime cleaningTime)? inProgress,
    TResult Function(CleaningTime cleaningTime)? stopped,
  }) {
    return any?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? any,
    TResult Function(CleaningTime cleaningTime)? inProgress,
    TResult Function(CleaningTime cleaningTime)? stopped,
    required TResult orElse(),
  }) {
    if (any != null) {
      return any();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CleaningTimeStateAny value) any,
    required TResult Function(CleaningTimeStateInProgress value) inProgress,
    required TResult Function(CleaningTimeStateStopped value) stopped,
  }) {
    return any(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(CleaningTimeStateAny value)? any,
    TResult Function(CleaningTimeStateInProgress value)? inProgress,
    TResult Function(CleaningTimeStateStopped value)? stopped,
  }) {
    return any?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CleaningTimeStateAny value)? any,
    TResult Function(CleaningTimeStateInProgress value)? inProgress,
    TResult Function(CleaningTimeStateStopped value)? stopped,
    required TResult orElse(),
  }) {
    if (any != null) {
      return any(this);
    }
    return orElse();
  }
}

abstract class CleaningTimeStateAny implements CleaningTimeState {
  const factory CleaningTimeStateAny() = _$CleaningTimeStateAny;
}

/// @nodoc
abstract class $CleaningTimeStateInProgressCopyWith<$Res> {
  factory $CleaningTimeStateInProgressCopyWith(
          CleaningTimeStateInProgress value,
          $Res Function(CleaningTimeStateInProgress) then) =
      _$CleaningTimeStateInProgressCopyWithImpl<$Res>;
  $Res call({CleaningTime cleaningTime});
}

/// @nodoc
class _$CleaningTimeStateInProgressCopyWithImpl<$Res>
    extends _$CleaningTimeStateCopyWithImpl<$Res>
    implements $CleaningTimeStateInProgressCopyWith<$Res> {
  _$CleaningTimeStateInProgressCopyWithImpl(CleaningTimeStateInProgress _value,
      $Res Function(CleaningTimeStateInProgress) _then)
      : super(_value, (v) => _then(v as CleaningTimeStateInProgress));

  @override
  CleaningTimeStateInProgress get _value =>
      super._value as CleaningTimeStateInProgress;

  @override
  $Res call({
    Object? cleaningTime = freezed,
  }) {
    return _then(CleaningTimeStateInProgress(
      cleaningTime: cleaningTime == freezed
          ? _value.cleaningTime
          : cleaningTime // ignore: cast_nullable_to_non_nullable
              as CleaningTime,
    ));
  }
}

/// @nodoc

class _$CleaningTimeStateInProgress implements CleaningTimeStateInProgress {
  const _$CleaningTimeStateInProgress({required this.cleaningTime});

  @override
  final CleaningTime cleaningTime;

  @override
  String toString() {
    return 'CleaningTimeState.inProgress(cleaningTime: $cleaningTime)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CleaningTimeStateInProgress &&
            const DeepCollectionEquality()
                .equals(other.cleaningTime, cleaningTime));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(cleaningTime));

  @JsonKey(ignore: true)
  @override
  $CleaningTimeStateInProgressCopyWith<CleaningTimeStateInProgress>
      get copyWith => _$CleaningTimeStateInProgressCopyWithImpl<
          CleaningTimeStateInProgress>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() any,
    required TResult Function(CleaningTime cleaningTime) inProgress,
    required TResult Function(CleaningTime cleaningTime) stopped,
  }) {
    return inProgress(cleaningTime);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? any,
    TResult Function(CleaningTime cleaningTime)? inProgress,
    TResult Function(CleaningTime cleaningTime)? stopped,
  }) {
    return inProgress?.call(cleaningTime);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? any,
    TResult Function(CleaningTime cleaningTime)? inProgress,
    TResult Function(CleaningTime cleaningTime)? stopped,
    required TResult orElse(),
  }) {
    if (inProgress != null) {
      return inProgress(cleaningTime);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CleaningTimeStateAny value) any,
    required TResult Function(CleaningTimeStateInProgress value) inProgress,
    required TResult Function(CleaningTimeStateStopped value) stopped,
  }) {
    return inProgress(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(CleaningTimeStateAny value)? any,
    TResult Function(CleaningTimeStateInProgress value)? inProgress,
    TResult Function(CleaningTimeStateStopped value)? stopped,
  }) {
    return inProgress?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CleaningTimeStateAny value)? any,
    TResult Function(CleaningTimeStateInProgress value)? inProgress,
    TResult Function(CleaningTimeStateStopped value)? stopped,
    required TResult orElse(),
  }) {
    if (inProgress != null) {
      return inProgress(this);
    }
    return orElse();
  }
}

abstract class CleaningTimeStateInProgress implements CleaningTimeState {
  const factory CleaningTimeStateInProgress(
      {required CleaningTime cleaningTime}) = _$CleaningTimeStateInProgress;

  CleaningTime get cleaningTime;
  @JsonKey(ignore: true)
  $CleaningTimeStateInProgressCopyWith<CleaningTimeStateInProgress>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CleaningTimeStateStoppedCopyWith<$Res> {
  factory $CleaningTimeStateStoppedCopyWith(CleaningTimeStateStopped value,
          $Res Function(CleaningTimeStateStopped) then) =
      _$CleaningTimeStateStoppedCopyWithImpl<$Res>;
  $Res call({CleaningTime cleaningTime});
}

/// @nodoc
class _$CleaningTimeStateStoppedCopyWithImpl<$Res>
    extends _$CleaningTimeStateCopyWithImpl<$Res>
    implements $CleaningTimeStateStoppedCopyWith<$Res> {
  _$CleaningTimeStateStoppedCopyWithImpl(CleaningTimeStateStopped _value,
      $Res Function(CleaningTimeStateStopped) _then)
      : super(_value, (v) => _then(v as CleaningTimeStateStopped));

  @override
  CleaningTimeStateStopped get _value =>
      super._value as CleaningTimeStateStopped;

  @override
  $Res call({
    Object? cleaningTime = freezed,
  }) {
    return _then(CleaningTimeStateStopped(
      cleaningTime: cleaningTime == freezed
          ? _value.cleaningTime
          : cleaningTime // ignore: cast_nullable_to_non_nullable
              as CleaningTime,
    ));
  }
}

/// @nodoc

class _$CleaningTimeStateStopped implements CleaningTimeStateStopped {
  const _$CleaningTimeStateStopped({required this.cleaningTime});

  @override
  final CleaningTime cleaningTime;

  @override
  String toString() {
    return 'CleaningTimeState.stopped(cleaningTime: $cleaningTime)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CleaningTimeStateStopped &&
            const DeepCollectionEquality()
                .equals(other.cleaningTime, cleaningTime));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(cleaningTime));

  @JsonKey(ignore: true)
  @override
  $CleaningTimeStateStoppedCopyWith<CleaningTimeStateStopped> get copyWith =>
      _$CleaningTimeStateStoppedCopyWithImpl<CleaningTimeStateStopped>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() any,
    required TResult Function(CleaningTime cleaningTime) inProgress,
    required TResult Function(CleaningTime cleaningTime) stopped,
  }) {
    return stopped(cleaningTime);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? any,
    TResult Function(CleaningTime cleaningTime)? inProgress,
    TResult Function(CleaningTime cleaningTime)? stopped,
  }) {
    return stopped?.call(cleaningTime);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? any,
    TResult Function(CleaningTime cleaningTime)? inProgress,
    TResult Function(CleaningTime cleaningTime)? stopped,
    required TResult orElse(),
  }) {
    if (stopped != null) {
      return stopped(cleaningTime);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CleaningTimeStateAny value) any,
    required TResult Function(CleaningTimeStateInProgress value) inProgress,
    required TResult Function(CleaningTimeStateStopped value) stopped,
  }) {
    return stopped(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(CleaningTimeStateAny value)? any,
    TResult Function(CleaningTimeStateInProgress value)? inProgress,
    TResult Function(CleaningTimeStateStopped value)? stopped,
  }) {
    return stopped?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CleaningTimeStateAny value)? any,
    TResult Function(CleaningTimeStateInProgress value)? inProgress,
    TResult Function(CleaningTimeStateStopped value)? stopped,
    required TResult orElse(),
  }) {
    if (stopped != null) {
      return stopped(this);
    }
    return orElse();
  }
}

abstract class CleaningTimeStateStopped implements CleaningTimeState {
  const factory CleaningTimeStateStopped({required CleaningTime cleaningTime}) =
      _$CleaningTimeStateStopped;

  CleaningTime get cleaningTime;
  @JsonKey(ignore: true)
  $CleaningTimeStateStoppedCopyWith<CleaningTimeStateStopped> get copyWith =>
      throw _privateConstructorUsedError;
}
